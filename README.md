# python-class-101
# Objective
Understanding OOPs concepts and its immplementation in Python

# Caveat
* This is NOT Production grade code
* It is intentionally a Python101 level code to illusrate concepts

# Goal
The goal is to take up the below problem domain, come up with the solution domain, logical modelling, and then implement that in Python

# Step 1: Problem Domain
I want to model employee life cycle in a company
* employee joins the company
* employee provides their Bank acct details into which salary must be credited
* company has 2 kinds of employees - Sales and Consulting
  * for Sales, salary structure is: Base + 3% of monthly bookings made by the sales person
  * for Consulting, salary is: Base + 2% of revenue booked by the consultant.
* at the end of month, company has to do a batch process of payroll for all employess
* employee can quits the company
* after employee quite, payroll process must EXCLUDE the employee (let's keep it simple here)
    
# Step 2: Solution Domain
Now that we have articulated the problem, we'll switch to the Solution Domain
* What are the 'things' we encounter in the Problem Domain?
  * Entity #1: Employee
  * Enity #2: SalesPerson "is an" Employee
  * Entity #3: Consultant "is an" Employee
  * all employess "have a" Bank Account
  * So that leads to Entity #4 Bank Account 
  * Company "has a" collection of employees

* Then, think about behavior (what do these things 'do' that's relevant to the Problem domain.)
  * employee "joins" the company
  * employee "leaves" the company
  * Company must "process payroll" for all active employess
  * when payroll is processeed, salary must "credited" to the Bank Acct of each active emp
  * SalesPerson "generates" Booking
  * Consultant "generates" Revenue
    
# Step 3: Now lets do the conceptual / logical modelling of the Solution Domain
In this step we identify members of Entities: attributes which hold state; and methods which model behaviour

## Employee Entity
* emp_id employee has an emp_id
* bank_acct # employee has a bank account
* base_pay # emloyee has a base pay
* quit() # and can quit
* what about joining? e.g join()? Well, when emp is created, we can implement the onboarding process as part of the process that's responsbility for creating the entity
* Think: Should Employee entity be modelled as an abstract entity or concreate entity? 
  * In the problem doamian, there are only 2 kinds of "real" employees: Sales Person and Consultant
  * every employee is either a Sales Person or Consultant
  * Now lets say the comapny wants to increase Head Count by 5 people, and decides "let's hire 5 employees."
  * that is a meaningful statement, but cannot be acted upon
  * to actually execute this, we need to ask one more question: "when you say 5 emps, how many are Sales Persons and how many are Consultants"
  * You never find positions being opened for "we are hiring employee!!" - too abstract!! Whereas "we are hiring Sales Persons", "we are hiring Consultants", that makes sense.
* Which is why, it is good to model the entity "employee" as a abstract entity, to reflect the real world reality
* **Design Decision**: Implement Employee as an abstract class.

## Sales Person _is an_ Employee
* set_monthly_booking(). We need this to record the bookings maded by the Sales Person
* process_pay() We'll use this  implement pay rules that are specifc to Sales Person
* **Design Descision**: Implement Sales Person as a sub-class (or child class) of Employee. Based on the _is a_ relationtionship.

## Consultant _is an_ Employee
* set_monthly_revenue(). We need this to record the Revenue generated by the Consultant when teh consultant delivers billable work
* process pay () We'll use this  implement pay rules that are specifc to Consultant
* **Design Descision**: Implement Consultant as a sub-class (or child class) of Employee. Based on the _is a_ relationtionship.

## What about additional functionality that we will need?
### Employee Id Generation
In real world, Emp ID's are typically maintained at Company level. So it does not make sense to pass emp id as an input parameter when we create employee objects. 
* **Design Decision**: provide functionality to auto generate emp_numbers.
* This is part of the functions that a Company does. So we need a wany to model the real world notion of a Company. Let's tackle that now.

### Company Entity
How do we model Company?
* Option 1 - model company as a Class.
  * **Design choice evaluation** What happens if we implement Company as a Class? 
     * That will allow creation of multiple instances of the Comapny. But in the real world, only one instance of the company exists. 
     * If the language allows us to enforce a mecchanism which allows the creation of a single instance of the class (referred to as singleton), we can use that. 
     * But here, we are doing a Level-101 implementaion, so lets not bother with Singletons
* Option 2 -  use Python Module to model the Company
  * **Design choice evaluation** What happens if we implement Company as a Module?  
     * Module provides a contained namespace in which all Company specific functions can be defined.
     * All that's meets our purpose now, as it provides a clean mechanism to organize all company level functionalites inside a namespace.
     * **Decision**: Use Module to implement Company
  * Company Module will:
    * generate emp ID
    * maintain a Collection of all employees (models the company's emp database)
    * Company will onboard and employee: when emp is created, emp must be added to the Collection (we will use a list)
    * when emp quits, Company will releive the employee. The emp must be removed from the Collection
    * and, most importanly, the Company must process payroll for all employees in the Collection

### Bank Account entity
When an employee joins the company, the employee has to provide their Bank Account details into which salary must be credited. So we need to model Bank Accout. 
Lets's keep things simple here. We need Account ID and Unique Identifier of the Bank.
* Account ID
* Bank ID
* deposit salary(). Payroll process can use this function to credit salary into the employee's bank account

# Step 4: Write Code and Test Code 
Now that we have done all the had work and done the logical modelling, its time to implement code
* Company.py >> this has the Class Module
* 03_2 Class101.py >> this implements all the classes, along with a test function to test the code

# Summary
We have taken a simplistic version of a real world problem, and have implemmeted in Python to get a feel for these concepts
* **Inheritence**
    * We used inheritence. Sales Person _is a_ Employee; a Consultant _is a_ Employeen. 
    * And we modelled all members common to both Sales Person and Consultant in the Employee Class
* **Composition** 
    * We used composition to model how Employee _has a_ bank account (one object contains another object)
* **Polymorphism**
    * We iterated through the list of employess that had both Sales Persors and Consultants. And called the process_pay() on each object;
      and yet the right member function was invoked, depending on whether the emp object was a Sales Person or an Consultant
* **Abstract Class**
    * We implemented Employee as an abstract class with 2 abstract methods.
* **Functional Decomposition**
    * we used Module to implement the notion of Company.
    * This allowed us to to decompose all company related functions and organize them in a logical unit
    * This illustrated how Object Oriented Programming and Procedural programming can both coexist - it is **not** an either/or choice. 
    * We make this design choice depending of what is most suitable for the problem at hand.
* **Domain Modelling**
    * We saw the value of modelling the domain before we started writing code
    * Logical modelling is a super important part of programming
    * Steps 1, 2 and 3 will apply even if the developers wants to implement the logical model in a different language, say Java or C++
* **Call to Action**    
    * Go ahead and run this. And improvise!! See comment at the bottom of 03_2 Class101.py
    * Hope this help clarify OOPS concepts and its implementation in Python
    * Enjoy Coding!!


